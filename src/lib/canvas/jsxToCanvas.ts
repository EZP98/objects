/**
 * JSX to Canvas Parser
 *
 * Converts React/Tailwind code generated by AI into canvas elements.
 * This allows us to leverage AI's excellent React generation while
 * maintaining visual canvas editing capabilities.
 */

import { CanvasElementData } from '../artifactParser';

/**
 * Tailwind class to canvas style mappings
 */
const TAILWIND_MAPPINGS: Record<string, (value?: string) => Record<string, unknown>> = {
  // Display
  'flex': () => ({ display: 'flex' }),
  'grid': () => ({ display: 'grid' }),
  'hidden': () => ({ display: 'none' }),
  'block': () => ({ display: 'block' }),

  // Flex Direction
  'flex-col': () => ({ flexDirection: 'column' }),
  'flex-row': () => ({ flexDirection: 'row' }),

  // Justify Content
  'justify-start': () => ({ justifyContent: 'flex-start' }),
  'justify-end': () => ({ justifyContent: 'flex-end' }),
  'justify-center': () => ({ justifyContent: 'center' }),
  'justify-between': () => ({ justifyContent: 'space-between' }),
  'justify-around': () => ({ justifyContent: 'space-around' }),

  // Align Items
  'items-start': () => ({ alignItems: 'flex-start' }),
  'items-end': () => ({ alignItems: 'flex-end' }),
  'items-center': () => ({ alignItems: 'center' }),
  'items-stretch': () => ({ alignItems: 'stretch' }),

  // Text Align
  'text-left': () => ({ textAlign: 'left' }),
  'text-center': () => ({ textAlign: 'center' }),
  'text-right': () => ({ textAlign: 'right' }),

  // Font Weight
  'font-thin': () => ({ fontWeight: 100 }),
  'font-light': () => ({ fontWeight: 300 }),
  'font-normal': () => ({ fontWeight: 400 }),
  'font-medium': () => ({ fontWeight: 500 }),
  'font-semibold': () => ({ fontWeight: 600 }),
  'font-bold': () => ({ fontWeight: 700 }),
  'font-extrabold': () => ({ fontWeight: 800 }),
  'font-black': () => ({ fontWeight: 900 }),

  // Border Radius
  'rounded-none': () => ({ borderRadius: 0 }),
  'rounded-sm': () => ({ borderRadius: 2 }),
  'rounded': () => ({ borderRadius: 4 }),
  'rounded-md': () => ({ borderRadius: 6 }),
  'rounded-lg': () => ({ borderRadius: 8 }),
  'rounded-xl': () => ({ borderRadius: 12 }),
  'rounded-2xl': () => ({ borderRadius: 16 }),
  'rounded-3xl': () => ({ borderRadius: 24 }),
  'rounded-full': () => ({ borderRadius: 9999 }),

  // Common sizes
  'w-full': () => ({ width: '100%' }),
  'h-full': () => ({ height: '100%' }),
  'min-h-screen': () => ({ minHeight: '100vh' }),
  'max-w-full': () => ({ maxWidth: '100%' }),
  'max-w-screen-sm': () => ({ maxWidth: 640 }),
  'max-w-screen-md': () => ({ maxWidth: 768 }),
  'max-w-screen-lg': () => ({ maxWidth: 1024 }),
  'max-w-screen-xl': () => ({ maxWidth: 1280 }),
  'max-w-screen-2xl': () => ({ maxWidth: 1536 }),
  'max-w-xs': () => ({ maxWidth: 320 }),
  'max-w-sm': () => ({ maxWidth: 384 }),
  'max-w-md': () => ({ maxWidth: 448 }),
  'max-w-lg': () => ({ maxWidth: 512 }),
  'max-w-xl': () => ({ maxWidth: 576 }),
  'max-w-2xl': () => ({ maxWidth: 672 }),
  'max-w-3xl': () => ({ maxWidth: 768 }),
  'max-w-4xl': () => ({ maxWidth: 896 }),
  'max-w-5xl': () => ({ maxWidth: 1024 }),
  'max-w-6xl': () => ({ maxWidth: 1152 }),
  'max-w-7xl': () => ({ maxWidth: 1280 }),

  // Line Height
  'leading-none': () => ({ lineHeight: 1 }),
  'leading-tight': () => ({ lineHeight: 1.25 }),
  'leading-snug': () => ({ lineHeight: 1.375 }),
  'leading-normal': () => ({ lineHeight: 1.5 }),
  'leading-relaxed': () => ({ lineHeight: 1.625 }),
  'leading-loose': () => ({ lineHeight: 2 }),

  // Letter Spacing
  'tracking-tighter': () => ({ letterSpacing: '-0.05em' }),
  'tracking-tight': () => ({ letterSpacing: '-0.025em' }),
  'tracking-normal': () => ({ letterSpacing: '0' }),
  'tracking-wide': () => ({ letterSpacing: '0.025em' }),
  'tracking-wider': () => ({ letterSpacing: '0.05em' }),
  'tracking-widest': () => ({ letterSpacing: '0.1em' }),

  // Border Width
  'border': () => ({ borderWidth: 1 }),
  'border-0': () => ({ borderWidth: 0 }),
  'border-2': () => ({ borderWidth: 2 }),
  'border-4': () => ({ borderWidth: 4 }),
  'border-8': () => ({ borderWidth: 8 }),

  // Overflow
  'overflow-hidden': () => ({ overflow: 'hidden' }),
  'overflow-auto': () => ({ overflow: 'auto' }),
  'overflow-scroll': () => ({ overflow: 'scroll' }),
  'overflow-visible': () => ({ overflow: 'visible' }),

  // Position
  'relative': () => ({ position: 'relative' }),
  'absolute': () => ({ position: 'absolute' }),
  'fixed': () => ({ position: 'fixed' }),
  'sticky': () => ({ position: 'sticky' }),

  // Inset
  'inset-0': () => ({ top: 0, right: 0, bottom: 0, left: 0 }),
  'top-0': () => ({ top: 0 }),
  'right-0': () => ({ right: 0 }),
  'bottom-0': () => ({ bottom: 0 }),
  'left-0': () => ({ left: 0 }),

  // Z-Index
  'z-0': () => ({ zIndex: 0 }),
  'z-10': () => ({ zIndex: 10 }),
  'z-20': () => ({ zIndex: 20 }),
  'z-30': () => ({ zIndex: 30 }),
  'z-40': () => ({ zIndex: 40 }),
  'z-50': () => ({ zIndex: 50 }),

  // Object Fit
  'object-contain': () => ({ objectFit: 'contain' }),
  'object-cover': () => ({ objectFit: 'cover' }),
  'object-fill': () => ({ objectFit: 'fill' }),
  'object-none': () => ({ objectFit: 'none' }),

  // Flex Wrap
  'flex-wrap': () => ({ flexWrap: 'wrap' }),
  'flex-nowrap': () => ({ flexWrap: 'nowrap' }),

  // Flex Grow/Shrink
  'flex-1': () => ({ flex: '1 1 0%' }),
  'flex-auto': () => ({ flex: '1 1 auto' }),
  'flex-initial': () => ({ flex: '0 1 auto' }),
  'flex-none': () => ({ flex: 'none' }),
  'grow': () => ({ flexGrow: 1 }),
  'grow-0': () => ({ flexGrow: 0 }),
  'shrink': () => ({ flexShrink: 1 }),
  'shrink-0': () => ({ flexShrink: 0 }),

  // Text Transform
  'uppercase': () => ({ textTransform: 'uppercase' }),
  'lowercase': () => ({ textTransform: 'lowercase' }),
  'capitalize': () => ({ textTransform: 'capitalize' }),
  'normal-case': () => ({ textTransform: 'none' }),

  // Text Decoration
  'underline': () => ({ textDecoration: 'underline' }),
  'line-through': () => ({ textDecoration: 'line-through' }),
  'no-underline': () => ({ textDecoration: 'none' }),

  // Whitespace
  'whitespace-normal': () => ({ whiteSpace: 'normal' }),
  'whitespace-nowrap': () => ({ whiteSpace: 'nowrap' }),
  'whitespace-pre': () => ({ whiteSpace: 'pre' }),

  // Cursor
  'cursor-pointer': () => ({ cursor: 'pointer' }),
  'cursor-default': () => ({ cursor: 'default' }),
  'cursor-not-allowed': () => ({ cursor: 'not-allowed' }),

  // Opacity
  'opacity-0': () => ({ opacity: 0 }),
  'opacity-25': () => ({ opacity: 0.25 }),
  'opacity-50': () => ({ opacity: 0.5 }),
  'opacity-75': () => ({ opacity: 0.75 }),
  'opacity-100': () => ({ opacity: 1 }),

  // Backdrop Blur (for glass effects)
  'backdrop-blur-sm': () => ({ backdropFilter: 'blur(4px)' }),
  'backdrop-blur': () => ({ backdropFilter: 'blur(8px)' }),
  'backdrop-blur-md': () => ({ backdropFilter: 'blur(12px)' }),
  'backdrop-blur-lg': () => ({ backdropFilter: 'blur(16px)' }),
  'backdrop-blur-xl': () => ({ backdropFilter: 'blur(24px)' }),
  'backdrop-blur-2xl': () => ({ backdropFilter: 'blur(40px)' }),
  'backdrop-blur-3xl': () => ({ backdropFilter: 'blur(64px)' }),
};

/**
 * Parse numeric Tailwind classes like p-4, m-8, gap-6, text-xl, etc.
 */
function parseNumericClass(className: string): Record<string, unknown> | null {
  // Spacing scale (Tailwind default)
  const spacingScale: Record<string, number> = {
    '0': 0, '0.5': 2, '1': 4, '1.5': 6, '2': 8, '2.5': 10,
    '3': 12, '3.5': 14, '4': 16, '5': 20, '6': 24, '7': 28,
    '8': 32, '9': 36, '10': 40, '11': 44, '12': 48, '14': 56,
    '16': 64, '20': 80, '24': 96, '28': 112, '32': 128,
    '36': 144, '40': 160, '44': 176, '48': 192, '52': 208,
    '56': 224, '60': 240, '64': 256, '72': 288, '80': 320,
    '96': 384,
  };

  // Font size scale
  const fontSizeScale: Record<string, number> = {
    'xs': 12, 'sm': 14, 'base': 16, 'lg': 18, 'xl': 20,
    '2xl': 24, '3xl': 30, '4xl': 36, '5xl': 48, '6xl': 60,
    '7xl': 72, '8xl': 96, '9xl': 128,
  };

  // Padding
  let match = className.match(/^p-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { padding: value };
  }

  match = className.match(/^px-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { paddingLeft: value, paddingRight: value };
  }

  match = className.match(/^py-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { paddingTop: value, paddingBottom: value };
  }

  match = className.match(/^pt-(\d+\.?\d*)$/);
  if (match) return { paddingTop: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pb-(\d+\.?\d*)$/);
  if (match) return { paddingBottom: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pl-(\d+\.?\d*)$/);
  if (match) return { paddingLeft: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pr-(\d+\.?\d*)$/);
  if (match) return { paddingRight: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Margin
  match = className.match(/^m-(\d+\.?\d*)$/);
  if (match) return { margin: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^mx-(\d+\.?\d*|auto)$/);
  if (match) {
    if (match[1] === 'auto') return { marginLeft: 'auto', marginRight: 'auto' };
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { marginLeft: value, marginRight: value };
  }

  match = className.match(/^my-(\d+\.?\d*)$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { marginTop: value, marginBottom: value };
  }

  // Gap
  match = className.match(/^gap-(\d+\.?\d*)$/);
  if (match) return { gap: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Font size
  match = className.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
  if (match) return { fontSize: fontSizeScale[match[1]] };

  // Width/Height with specific values
  match = className.match(/^w-(\d+)$/);
  if (match) return { width: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^h-(\d+)$/);
  if (match) return { height: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^max-w-(\d+)$/);
  if (match) return { maxWidth: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Arbitrary values [100px], [#fff], etc.
  match = className.match(/^\w+-\[(.+)\]$/);
  if (match) {
    const prop = className.split('-[')[0];
    const value = match[1];

    // Map common properties
    const propMap: Record<string, string> = {
      'w': 'width', 'h': 'height', 'p': 'padding', 'm': 'margin',
      'px': 'paddingLeft', 'py': 'paddingTop', 'gap': 'gap',
      'text': 'fontSize', 'bg': 'backgroundColor', 'rounded': 'borderRadius',
    };

    const cssProp = propMap[prop];
    if (cssProp) {
      // Parse numeric values
      const numMatch = value.match(/^(\d+)px$/);
      if (numMatch) return { [cssProp]: parseInt(numMatch[1]) };
      return { [cssProp]: value };
    }
  }

  return null;
}

/**
 * Full Tailwind color palette
 */
const TAILWIND_COLORS: Record<string, string> = {
  'white': '#ffffff',
  'black': '#000000',
  'transparent': 'transparent',
  // Slate
  'slate-50': '#f8fafc', 'slate-100': '#f1f5f9', 'slate-200': '#e2e8f0',
  'slate-300': '#cbd5e1', 'slate-400': '#94a3b8', 'slate-500': '#64748b',
  'slate-600': '#475569', 'slate-700': '#334155', 'slate-800': '#1e293b',
  'slate-900': '#0f172a', 'slate-950': '#020617',
  // Gray
  'gray-50': '#f9fafb', 'gray-100': '#f3f4f6', 'gray-200': '#e5e7eb',
  'gray-300': '#d1d5db', 'gray-400': '#9ca3af', 'gray-500': '#6b7280',
  'gray-600': '#4b5563', 'gray-700': '#374151', 'gray-800': '#1f2937',
  'gray-900': '#111827', 'gray-950': '#030712',
  // Zinc
  'zinc-50': '#fafafa', 'zinc-100': '#f4f4f5', 'zinc-200': '#e4e4e7',
  'zinc-300': '#d4d4d8', 'zinc-400': '#a1a1aa', 'zinc-500': '#71717a',
  'zinc-600': '#52525b', 'zinc-700': '#3f3f46', 'zinc-800': '#27272a',
  'zinc-900': '#18181b', 'zinc-950': '#09090b',
  // Neutral
  'neutral-50': '#fafafa', 'neutral-100': '#f5f5f5', 'neutral-200': '#e5e5e5',
  'neutral-300': '#d4d4d4', 'neutral-400': '#a3a3a3', 'neutral-500': '#737373',
  'neutral-600': '#525252', 'neutral-700': '#404040', 'neutral-800': '#262626',
  'neutral-900': '#171717', 'neutral-950': '#0a0a0a',
  // Red
  'red-50': '#fef2f2', 'red-100': '#fee2e2', 'red-200': '#fecaca',
  'red-300': '#fca5a5', 'red-400': '#f87171', 'red-500': '#ef4444',
  'red-600': '#dc2626', 'red-700': '#b91c1c', 'red-800': '#991b1b',
  'red-900': '#7f1d1d', 'red-950': '#450a0a',
  // Orange
  'orange-50': '#fff7ed', 'orange-100': '#ffedd5', 'orange-200': '#fed7aa',
  'orange-300': '#fdba74', 'orange-400': '#fb923c', 'orange-500': '#f97316',
  'orange-600': '#ea580c', 'orange-700': '#c2410c', 'orange-800': '#9a3412',
  'orange-900': '#7c2d12', 'orange-950': '#431407',
  // Amber
  'amber-50': '#fffbeb', 'amber-100': '#fef3c7', 'amber-200': '#fde68a',
  'amber-300': '#fcd34d', 'amber-400': '#fbbf24', 'amber-500': '#f59e0b',
  'amber-600': '#d97706', 'amber-700': '#b45309', 'amber-800': '#92400e',
  'amber-900': '#78350f', 'amber-950': '#451a03',
  // Yellow
  'yellow-50': '#fefce8', 'yellow-100': '#fef9c3', 'yellow-200': '#fef08a',
  'yellow-300': '#fde047', 'yellow-400': '#facc15', 'yellow-500': '#eab308',
  'yellow-600': '#ca8a04', 'yellow-700': '#a16207', 'yellow-800': '#854d0e',
  'yellow-900': '#713f12', 'yellow-950': '#422006',
  // Lime
  'lime-50': '#f7fee7', 'lime-100': '#ecfccb', 'lime-200': '#d9f99d',
  'lime-300': '#bef264', 'lime-400': '#a3e635', 'lime-500': '#84cc16',
  'lime-600': '#65a30d', 'lime-700': '#4d7c0f', 'lime-800': '#3f6212',
  'lime-900': '#365314', 'lime-950': '#1a2e05',
  // Green
  'green-50': '#f0fdf4', 'green-100': '#dcfce7', 'green-200': '#bbf7d0',
  'green-300': '#86efac', 'green-400': '#4ade80', 'green-500': '#22c55e',
  'green-600': '#16a34a', 'green-700': '#15803d', 'green-800': '#166534',
  'green-900': '#14532d', 'green-950': '#052e16',
  // Emerald
  'emerald-50': '#ecfdf5', 'emerald-100': '#d1fae5', 'emerald-200': '#a7f3d0',
  'emerald-300': '#6ee7b7', 'emerald-400': '#34d399', 'emerald-500': '#10b981',
  'emerald-600': '#059669', 'emerald-700': '#047857', 'emerald-800': '#065f46',
  'emerald-900': '#064e3b', 'emerald-950': '#022c22',
  // Teal
  'teal-50': '#f0fdfa', 'teal-100': '#ccfbf1', 'teal-200': '#99f6e4',
  'teal-300': '#5eead4', 'teal-400': '#2dd4bf', 'teal-500': '#14b8a6',
  'teal-600': '#0d9488', 'teal-700': '#0f766e', 'teal-800': '#115e59',
  'teal-900': '#134e4a', 'teal-950': '#042f2e',
  // Cyan
  'cyan-50': '#ecfeff', 'cyan-100': '#cffafe', 'cyan-200': '#a5f3fc',
  'cyan-300': '#67e8f9', 'cyan-400': '#22d3ee', 'cyan-500': '#06b6d4',
  'cyan-600': '#0891b2', 'cyan-700': '#0e7490', 'cyan-800': '#155e75',
  'cyan-900': '#164e63', 'cyan-950': '#083344',
  // Sky
  'sky-50': '#f0f9ff', 'sky-100': '#e0f2fe', 'sky-200': '#bae6fd',
  'sky-300': '#7dd3fc', 'sky-400': '#38bdf8', 'sky-500': '#0ea5e9',
  'sky-600': '#0284c7', 'sky-700': '#0369a1', 'sky-800': '#075985',
  'sky-900': '#0c4a6e', 'sky-950': '#082f49',
  // Blue
  'blue-50': '#eff6ff', 'blue-100': '#dbeafe', 'blue-200': '#bfdbfe',
  'blue-300': '#93c5fd', 'blue-400': '#60a5fa', 'blue-500': '#3b82f6',
  'blue-600': '#2563eb', 'blue-700': '#1d4ed8', 'blue-800': '#1e40af',
  'blue-900': '#1e3a8a', 'blue-950': '#172554',
  // Indigo
  'indigo-50': '#eef2ff', 'indigo-100': '#e0e7ff', 'indigo-200': '#c7d2fe',
  'indigo-300': '#a5b4fc', 'indigo-400': '#818cf8', 'indigo-500': '#6366f1',
  'indigo-600': '#4f46e5', 'indigo-700': '#4338ca', 'indigo-800': '#3730a3',
  'indigo-900': '#312e81', 'indigo-950': '#1e1b4b',
  // Violet
  'violet-50': '#f5f3ff', 'violet-100': '#ede9fe', 'violet-200': '#ddd6fe',
  'violet-300': '#c4b5fd', 'violet-400': '#a78bfa', 'violet-500': '#8b5cf6',
  'violet-600': '#7c3aed', 'violet-700': '#6d28d9', 'violet-800': '#5b21b6',
  'violet-900': '#4c1d95', 'violet-950': '#2e1065',
  // Purple
  'purple-50': '#faf5ff', 'purple-100': '#f3e8ff', 'purple-200': '#e9d5ff',
  'purple-300': '#d8b4fe', 'purple-400': '#c084fc', 'purple-500': '#a855f7',
  'purple-600': '#9333ea', 'purple-700': '#7e22ce', 'purple-800': '#6b21a8',
  'purple-900': '#581c87', 'purple-950': '#3b0764',
  // Fuchsia
  'fuchsia-50': '#fdf4ff', 'fuchsia-100': '#fae8ff', 'fuchsia-200': '#f5d0fe',
  'fuchsia-300': '#f0abfc', 'fuchsia-400': '#e879f9', 'fuchsia-500': '#d946ef',
  'fuchsia-600': '#c026d3', 'fuchsia-700': '#a21caf', 'fuchsia-800': '#86198f',
  'fuchsia-900': '#701a75', 'fuchsia-950': '#4a044e',
  // Pink
  'pink-50': '#fdf2f8', 'pink-100': '#fce7f3', 'pink-200': '#fbcfe8',
  'pink-300': '#f9a8d4', 'pink-400': '#f472b6', 'pink-500': '#ec4899',
  'pink-600': '#db2777', 'pink-700': '#be185d', 'pink-800': '#9d174d',
  'pink-900': '#831843', 'pink-950': '#500724',
  // Rose
  'rose-50': '#fff1f2', 'rose-100': '#ffe4e6', 'rose-200': '#fecdd3',
  'rose-300': '#fda4af', 'rose-400': '#fb7185', 'rose-500': '#f43f5e',
  'rose-600': '#e11d48', 'rose-700': '#be123c', 'rose-800': '#9f1239',
  'rose-900': '#881337', 'rose-950': '#4c0519',
};

/**
 * Gradient direction mapping
 */
const GRADIENT_DIRECTIONS: Record<string, string> = {
  'to-t': 'to top',
  'to-tr': 'to top right',
  'to-r': 'to right',
  'to-br': 'to bottom right',
  'to-b': 'to bottom',
  'to-bl': 'to bottom left',
  'to-l': 'to left',
  'to-tl': 'to top left',
};

/**
 * Parse color with optional opacity (e.g., white/10, slate-900/50)
 */
function parseColorWithOpacity(colorName: string): string | null {
  // Check for opacity modifier
  const opacityMatch = colorName.match(/^(.+)\/(\d+)$/);
  if (opacityMatch) {
    const baseColor = opacityMatch[1];
    const opacity = parseInt(opacityMatch[2]) / 100;
    const hexColor = TAILWIND_COLORS[baseColor];
    if (hexColor && hexColor !== 'transparent') {
      // Convert hex to rgba
      const r = parseInt(hexColor.slice(1, 3), 16);
      const g = parseInt(hexColor.slice(3, 5), 16);
      const b = parseInt(hexColor.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
  }
  return TAILWIND_COLORS[colorName] || null;
}

/**
 * Parse gradient classes (bg-gradient-to-br from-violet-600 to-indigo-600)
 */
function parseGradientClasses(classes: string[]): Record<string, unknown> | null {
  let direction = '';
  let fromColor = '';
  let viaColor = '';
  let toColor = '';

  for (const cls of classes) {
    // Gradient direction (bg-gradient-to-br, bg-gradient-to-r, etc.)
    if (cls.startsWith('bg-gradient-')) {
      const dir = cls.replace('bg-gradient-', '');
      direction = GRADIENT_DIRECTIONS[dir] || 'to bottom';
    }
    // From color (from-violet-600, from-white/10, etc.)
    else if (cls.startsWith('from-')) {
      const colorName = cls.replace('from-', '');
      fromColor = parseColorWithOpacity(colorName) || TAILWIND_COLORS[colorName] || '';
    }
    // Via color (optional middle color)
    else if (cls.startsWith('via-')) {
      const colorName = cls.replace('via-', '');
      viaColor = parseColorWithOpacity(colorName) || TAILWIND_COLORS[colorName] || '';
    }
    // To color (to-indigo-600, to-transparent, etc.)
    // Note: "to-" colors are NOT direction classes - those are in bg-gradient-to-*
    else if (cls.startsWith('to-')) {
      const colorName = cls.replace('to-', '');
      // Check if this is a valid color (not a leftover direction part)
      const color = parseColorWithOpacity(colorName) || TAILWIND_COLORS[colorName];
      if (color) {
        toColor = color;
      }
    }
  }

  if (direction && fromColor) {
    let gradient = `linear-gradient(${direction}, ${fromColor}`;
    if (viaColor) {
      gradient += `, ${viaColor}`;
    }
    if (toColor) {
      gradient += `, ${toColor}`;
    }
    gradient += ')';
    return { backgroundImage: gradient };
  }

  return null;
}

/**
 * Parse color classes like bg-slate-900, text-white, etc.
 */
function parseColorClass(className: string): Record<string, unknown> | null {
  // Background color (with opacity support)
  let match = className.match(/^bg-(.+)$/);
  if (match) {
    const color = parseColorWithOpacity(match[1]);
    if (color) {
      return { backgroundColor: color };
    }
  }

  // Text color (with opacity support)
  match = className.match(/^text-(.+)$/);
  if (match) {
    const color = parseColorWithOpacity(match[1]);
    if (color) {
      return { color };
    }
  }

  // Border color (with opacity support)
  match = className.match(/^border-(.+)$/);
  if (match) {
    const color = parseColorWithOpacity(match[1]);
    if (color) {
      return { borderColor: color };
    }
  }

  // Shadow color (shadow-violet-500/20)
  match = className.match(/^shadow-(.+)$/);
  if (match && match[1].includes('-')) {
    // This is a colored shadow, not shadow size
    // We'll handle this in a combined way with shadow size
    return null;
  }

  return null;
}

/**
 * Convert Tailwind className string to canvas styles
 */
export function tailwindToStyles(className: string): Record<string, unknown> {
  const styles: Record<string, unknown> = {};
  const classes = className.split(/\s+/).filter(Boolean);

  // Check for gradient classes first (they need to be parsed together)
  const hasGradient = classes.some(cls => cls.startsWith('bg-gradient-'));
  if (hasGradient) {
    const gradientStyles = parseGradientClasses(classes);
    if (gradientStyles) {
      Object.assign(styles, gradientStyles);
    }
  }

  for (const cls of classes) {
    // Skip responsive prefixes for now (sm:, md:, lg:, etc.)
    if (cls.includes(':')) continue;

    // Skip gradient-related classes (already processed by parseGradientClasses)
    if (hasGradient && (
      cls.startsWith('bg-gradient-') ||
      cls.startsWith('from-') ||
      cls.startsWith('via-') ||
      cls.startsWith('to-')
    )) {
      continue;
    }

    // Try static mappings first
    if (TAILWIND_MAPPINGS[cls]) {
      Object.assign(styles, TAILWIND_MAPPINGS[cls]());
      continue;
    }

    // Try numeric class parsing
    const numericStyles = parseNumericClass(cls);
    if (numericStyles) {
      Object.assign(styles, numericStyles);
      continue;
    }

    // Try color class parsing
    const colorStyles = parseColorClass(cls);
    if (colorStyles) {
      Object.assign(styles, colorStyles);
      continue;
    }

    // Handle shadow classes
    if (cls.startsWith('shadow')) {
      const shadowStyles = parseShadowClass(cls);
      if (shadowStyles) {
        Object.assign(styles, shadowStyles);
        continue;
      }
    }
  }

  return styles;
}

/**
 * Parse shadow classes (shadow, shadow-lg, shadow-2xl, etc.)
 */
function parseShadowClass(className: string): Record<string, unknown> | null {
  const shadowMap: Record<string, string> = {
    'shadow-sm': '0 1px 2px 0 rgb(0 0 0 / 0.05)',
    'shadow': '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
    'shadow-md': '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
    'shadow-lg': '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
    'shadow-xl': '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
    'shadow-2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
    'shadow-inner': 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
    'shadow-none': 'none',
  };

  if (shadowMap[className]) {
    return { boxShadow: shadowMap[className] };
  }

  return null;
}

/**
 * Determine element type from HTML tag
 */
function getElementType(tag: string): string {
  const tagMap: Record<string, string> = {
    'div': 'frame',
    'section': 'section',
    'header': 'section',
    'footer': 'section',
    'nav': 'row',
    'main': 'section',
    'article': 'frame',
    'aside': 'frame',
    'span': 'text',
    'p': 'text',
    'h1': 'text',
    'h2': 'text',
    'h3': 'text',
    'h4': 'text',
    'h5': 'text',
    'h6': 'text',
    'button': 'button',
    'a': 'button',
    'img': 'image',
    'input': 'input',
    'ul': 'stack',
    'ol': 'stack',
    'li': 'frame',
  };
  return tagMap[tag.toLowerCase()] || 'frame';
}

/**
 * Extract element name from className or generate one
 */
function generateElementName(tag: string, className: string, index: number): string {
  // Try to infer name from semantic classes
  if (className.includes('header')) return 'Header';
  if (className.includes('hero')) return 'Hero';
  if (className.includes('footer')) return 'Footer';
  if (className.includes('nav')) return 'Nav';
  if (className.includes('card')) return `Card${index}`;
  if (className.includes('button') || className.includes('btn')) return 'Button';

  // Default names based on tag
  const tagNames: Record<string, string> = {
    'h1': 'Title',
    'h2': 'Heading',
    'h3': 'Subheading',
    'p': 'Text',
    'button': 'Button',
    'img': 'Image',
    'section': 'Section',
    'header': 'Header',
    'footer': 'Footer',
    'nav': 'Nav',
  };

  return tagNames[tag.toLowerCase()] || `Element${index}`;
}

interface ParsedJSXElement {
  tag: string;
  className: string;
  children: (ParsedJSXElement | string)[];
  props: Record<string, string>;
}

/**
 * Simple JSX parser using regex
 * Note: This is a simplified parser that handles common cases.
 * For production, consider using @babel/parser
 */
function parseJSXString(jsx: string): ParsedJSXElement[] {
  const elements: ParsedJSXElement[] = [];

  // Remove comments
  jsx = jsx.replace(/\{\/\*[\s\S]*?\*\/\}/g, '');
  jsx = jsx.replace(/\/\/.*$/gm, '');

  // Simple recursive parser
  function parseElement(str: string, startIndex: number = 0): { element: ParsedJSXElement | string | null; endIndex: number } {
    str = str.trim();

    // Check for text content
    if (!str.startsWith('<')) {
      const nextTagIndex = str.indexOf('<');
      if (nextTagIndex === -1) {
        return { element: str.trim() || null, endIndex: str.length };
      }
      const text = str.substring(0, nextTagIndex).trim();
      return { element: text || null, endIndex: nextTagIndex };
    }

    // Handle React Fragment shorthand <> ... </>
    if (str.startsWith('<>')) {
      // Find the closing </> and extract content
      const closeIndex = str.lastIndexOf('</>');
      if (closeIndex > 2) {
        const fragmentContent = str.substring(2, closeIndex).trim();
        // Parse content inside fragment and return as array wrapped in a virtual container
        const fragmentElements: ParsedJSXElement[] = [];
        let childIndex = 0;
        while (childIndex < fragmentContent.length) {
          const { element: child, endIndex } = parseElement(fragmentContent.substring(childIndex));
          if (child && typeof child !== 'string') {
            fragmentElements.push(child);
          }
          if (endIndex === 0) break;
          childIndex += endIndex;
        }
        // Return first element or wrap multiple in a virtual frame
        if (fragmentElements.length === 1) {
          return { element: fragmentElements[0], endIndex: closeIndex + 3 };
        } else if (fragmentElements.length > 1) {
          // Create a virtual container for multiple fragment children
          return {
            element: {
              tag: 'div',
              className: 'flex flex-col w-full',
              children: fragmentElements,
              props: {},
            },
            endIndex: closeIndex + 3,
          };
        }
      }
      return { element: null, endIndex: str.length };
    }

    // Parse opening tag
    const openTagMatch = str.match(/^<(\w+)([^>]*?)(\/?)>/);
    if (!openTagMatch) {
      return { element: null, endIndex: str.length };
    }

    const [fullMatch, tag, attrsStr, selfClosing] = openTagMatch;

    // Parse attributes
    const props: Record<string, string> = {};
    let className = '';

    // Extract className
    const classNameMatch = attrsStr.match(/className=["']([^"']+)["']/);
    if (classNameMatch) {
      className = classNameMatch[1];
    }

    // Extract src for images
    const srcMatch = attrsStr.match(/src=["']([^"']+)["']/);
    if (srcMatch) {
      props.src = srcMatch[1];
    }

    // Extract href for links
    const hrefMatch = attrsStr.match(/href=["']([^"']+)["']/);
    if (hrefMatch) {
      props.href = hrefMatch[1];
    }

    const element: ParsedJSXElement = {
      tag,
      className,
      children: [],
      props,
    };

    // Self-closing tag
    if (selfClosing === '/') {
      return { element, endIndex: fullMatch.length };
    }

    // Find matching closing tag and parse children
    let depth = 1;
    let currentIndex = fullMatch.length;
    let childrenStr = '';

    while (depth > 0 && currentIndex < str.length) {
      const openMatch = str.substring(currentIndex).match(/^<(\w+)/);
      const closeMatch = str.substring(currentIndex).match(/^<\/(\w+)>/);

      if (closeMatch && closeMatch[1] === tag) {
        depth--;
        if (depth === 0) {
          // Parse children
          if (childrenStr.trim()) {
            let childIndex = 0;
            while (childIndex < childrenStr.length) {
              const { element: child, endIndex } = parseElement(childrenStr.substring(childIndex));
              if (child) {
                element.children.push(child);
              }
              if (endIndex === 0) break;
              childIndex += endIndex;
            }
          }
          return { element, endIndex: currentIndex + closeMatch[0].length };
        }
      } else if (openMatch) {
        // Check if it's a self-closing tag
        const selfCloseCheck = str.substring(currentIndex).match(/^<\w+[^>]*\/>/);
        if (!selfCloseCheck) {
          depth++;
        }
      }

      childrenStr += str[currentIndex];
      currentIndex++;
    }

    return { element, endIndex: currentIndex };
  }

  // Parse top-level elements
  let index = 0;
  while (index < jsx.length) {
    const { element, endIndex } = parseElement(jsx.substring(index));
    if (element && typeof element !== 'string') {
      elements.push(element);
    }
    if (endIndex === 0) break;
    index += endIndex;
  }

  return elements;
}

/**
 * Convert parsed JSX element to CanvasElementData
 */
function jsxElementToCanvas(
  element: ParsedJSXElement | string,
  index: number = 0
): CanvasElementData | null {
  // Handle text nodes
  if (typeof element === 'string') {
    const text = element.trim();
    if (!text || text.startsWith('{')) return null; // Skip empty or JSX expressions

    return {
      type: 'text',
      name: 'Text',
      content: text,
      styles: {},
    };
  }

  const { tag, className, children, props } = element;
  const type = getElementType(tag);
  const name = generateElementName(tag, className, index);
  const styles = tailwindToStyles(className);

  // Build canvas element
  const canvasElement: CanvasElementData = {
    type,
    name,
    styles,
  };

  // Add content for text elements
  if (type === 'text' || type === 'button') {
    const textContent = children
      .filter((c): c is string => typeof c === 'string')
      .join(' ')
      .trim();
    if (textContent) {
      canvasElement.content = textContent;
    }
  }

  // Add src for images
  if (type === 'image' && props.src) {
    canvasElement.src = props.src;
  }

  // Add href for links/buttons
  if (props.href) {
    canvasElement.href = props.href;
  }

  // Process children (for containers)
  if (type !== 'text' && type !== 'button') {
    const childElements = children
      .map((child, i) => jsxElementToCanvas(child, i))
      .filter((c): c is CanvasElementData => c !== null);

    if (childElements.length > 0) {
      canvasElement.children = childElements;
    }
  }

  return canvasElement;
}

/**
 * Main function: Parse JSX/TSX code and convert to canvas elements
 */
export function parseJSXToCanvas(code: string): CanvasElementData[] {
  console.log('[JSX Parser] Parsing code...');

  // Extract JSX from the return statement
  const returnMatch = code.match(/return\s*\(\s*([\s\S]*?)\s*\);?\s*\}?\s*$/);
  const jsxContent = returnMatch ? returnMatch[1] : code;

  // Also try to find JSX in the whole code if return didn't match
  const jsxMatch = jsxContent.match(/<[\s\S]+>/);
  if (!jsxMatch) {
    console.warn('[JSX Parser] No JSX found in code');
    return [];
  }

  const jsx = jsxMatch[0];
  console.log('[JSX Parser] Found JSX:', jsx.substring(0, 200) + '...');

  // Parse JSX structure
  const parsedElements = parseJSXString(jsx);
  console.log('[JSX Parser] Parsed elements:', parsedElements.length);

  // Convert to canvas elements
  const canvasElements = parsedElements
    .map((el, i) => jsxElementToCanvas(el, i))
    .filter((el): el is CanvasElementData => el !== null);

  console.log('[JSX Parser] Canvas elements:', canvasElements.length);

  return canvasElements;
}

/**
 * Extract JSX code blocks from AI response
 */
export function extractJSXFromResponse(response: string): string[] {
  const codeBlocks: string[] = [];

  console.log('[extractJSX] Input length:', response.length);
  console.log('[extractJSX] First 300 chars:', JSON.stringify(response.substring(0, 300)));
  console.log('[extractJSX] Has backticks:', response.includes('```'));
  console.log('[extractJSX] Has tsx:', response.includes('tsx'));

  // Find backtick positions for debugging
  const backtickPos = response.indexOf('```');
  if (backtickPos >= 0) {
    console.log('[extractJSX] First ``` at position:', backtickPos);
    console.log('[extractJSX] Chars around first ```:', JSON.stringify(response.substring(Math.max(0, backtickPos - 5), backtickPos + 20)));
  }

  // Try multiple patterns to catch different code block formats
  // Pattern 1: ```tsx or ```jsx with newline (standard)
  let matches = response.matchAll(/```(?:tsx?|jsx?)\s*\n([\s\S]*?)```/gi);
  for (const match of matches) {
    console.log('[extractJSX] Found pattern 1 match, length:', match[1].length);
    codeBlocks.push(match[1]);
  }

  // Pattern 2: Just ``` with code that looks like React
  if (codeBlocks.length === 0) {
    matches = response.matchAll(/```\s*\n?([\s\S]*?)```/g);
    for (const match of matches) {
      const code = match[1];
      // Check if it looks like React code
      if (code.includes('export') || code.includes('function') || code.includes('return') || code.includes('<')) {
        console.log('[extractJSX] Found pattern 2 match (generic), length:', code.length);
        codeBlocks.push(code);
      }
    }
  }

  // Pattern 3: Try to find inline React component without code blocks
  if (codeBlocks.length === 0) {
    // Look for export default function or function Component patterns
    const inlineMatch = response.match(/((?:export\s+default\s+)?function\s+\w+\s*\([^)]*\)\s*\{[\s\S]*?return\s*\([\s\S]*?\)[;\s]*\})/);
    if (inlineMatch) {
      console.log('[extractJSX] Found inline component, length:', inlineMatch[1].length);
      codeBlocks.push(inlineMatch[1]);
    }
  }

  console.log('[extractJSX] Total code blocks found:', codeBlocks.length);
  return codeBlocks;
}

export default parseJSXToCanvas;
