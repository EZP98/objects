/**
 * JSX to Canvas Parser
 *
 * Converts React/Tailwind code generated by AI into canvas elements.
 * This allows us to leverage AI's excellent React generation while
 * maintaining visual canvas editing capabilities.
 */

import { CanvasElementData } from '../artifactParser';

/**
 * Tailwind class to canvas style mappings
 */
const TAILWIND_MAPPINGS: Record<string, (value?: string) => Record<string, unknown>> = {
  // Display
  'flex': () => ({ display: 'flex' }),
  'grid': () => ({ display: 'grid' }),
  'hidden': () => ({ display: 'none' }),
  'block': () => ({ display: 'block' }),

  // Flex Direction
  'flex-col': () => ({ flexDirection: 'column' }),
  'flex-row': () => ({ flexDirection: 'row' }),

  // Justify Content
  'justify-start': () => ({ justifyContent: 'flex-start' }),
  'justify-end': () => ({ justifyContent: 'flex-end' }),
  'justify-center': () => ({ justifyContent: 'center' }),
  'justify-between': () => ({ justifyContent: 'space-between' }),
  'justify-around': () => ({ justifyContent: 'space-around' }),

  // Align Items
  'items-start': () => ({ alignItems: 'flex-start' }),
  'items-end': () => ({ alignItems: 'flex-end' }),
  'items-center': () => ({ alignItems: 'center' }),
  'items-stretch': () => ({ alignItems: 'stretch' }),

  // Text Align
  'text-left': () => ({ textAlign: 'left' }),
  'text-center': () => ({ textAlign: 'center' }),
  'text-right': () => ({ textAlign: 'right' }),

  // Font Weight
  'font-thin': () => ({ fontWeight: 100 }),
  'font-light': () => ({ fontWeight: 300 }),
  'font-normal': () => ({ fontWeight: 400 }),
  'font-medium': () => ({ fontWeight: 500 }),
  'font-semibold': () => ({ fontWeight: 600 }),
  'font-bold': () => ({ fontWeight: 700 }),
  'font-extrabold': () => ({ fontWeight: 800 }),
  'font-black': () => ({ fontWeight: 900 }),

  // Border Radius
  'rounded-none': () => ({ borderRadius: 0 }),
  'rounded-sm': () => ({ borderRadius: 2 }),
  'rounded': () => ({ borderRadius: 4 }),
  'rounded-md': () => ({ borderRadius: 6 }),
  'rounded-lg': () => ({ borderRadius: 8 }),
  'rounded-xl': () => ({ borderRadius: 12 }),
  'rounded-2xl': () => ({ borderRadius: 16 }),
  'rounded-3xl': () => ({ borderRadius: 24 }),
  'rounded-full': () => ({ borderRadius: 9999 }),

  // Common sizes
  'w-full': () => ({ width: '100%' }),
  'h-full': () => ({ height: '100%' }),
  'min-h-screen': () => ({ minHeight: '100vh' }),
};

/**
 * Parse numeric Tailwind classes like p-4, m-8, gap-6, text-xl, etc.
 */
function parseNumericClass(className: string): Record<string, unknown> | null {
  // Spacing scale (Tailwind default)
  const spacingScale: Record<string, number> = {
    '0': 0, '0.5': 2, '1': 4, '1.5': 6, '2': 8, '2.5': 10,
    '3': 12, '3.5': 14, '4': 16, '5': 20, '6': 24, '7': 28,
    '8': 32, '9': 36, '10': 40, '11': 44, '12': 48, '14': 56,
    '16': 64, '20': 80, '24': 96, '28': 112, '32': 128,
    '36': 144, '40': 160, '44': 176, '48': 192, '52': 208,
    '56': 224, '60': 240, '64': 256, '72': 288, '80': 320,
    '96': 384,
  };

  // Font size scale
  const fontSizeScale: Record<string, number> = {
    'xs': 12, 'sm': 14, 'base': 16, 'lg': 18, 'xl': 20,
    '2xl': 24, '3xl': 30, '4xl': 36, '5xl': 48, '6xl': 60,
    '7xl': 72, '8xl': 96, '9xl': 128,
  };

  // Padding
  let match = className.match(/^p-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { padding: value };
  }

  match = className.match(/^px-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { paddingLeft: value, paddingRight: value };
  }

  match = className.match(/^py-(\d+\.?\d*|\[.+\])$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { paddingTop: value, paddingBottom: value };
  }

  match = className.match(/^pt-(\d+\.?\d*)$/);
  if (match) return { paddingTop: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pb-(\d+\.?\d*)$/);
  if (match) return { paddingBottom: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pl-(\d+\.?\d*)$/);
  if (match) return { paddingLeft: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^pr-(\d+\.?\d*)$/);
  if (match) return { paddingRight: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Margin
  match = className.match(/^m-(\d+\.?\d*)$/);
  if (match) return { margin: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^mx-(\d+\.?\d*|auto)$/);
  if (match) {
    if (match[1] === 'auto') return { marginLeft: 'auto', marginRight: 'auto' };
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { marginLeft: value, marginRight: value };
  }

  match = className.match(/^my-(\d+\.?\d*)$/);
  if (match) {
    const value = spacingScale[match[1]] ?? parseInt(match[1]) * 4;
    return { marginTop: value, marginBottom: value };
  }

  // Gap
  match = className.match(/^gap-(\d+\.?\d*)$/);
  if (match) return { gap: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Font size
  match = className.match(/^text-(xs|sm|base|lg|xl|2xl|3xl|4xl|5xl|6xl|7xl|8xl|9xl)$/);
  if (match) return { fontSize: fontSizeScale[match[1]] };

  // Width/Height with specific values
  match = className.match(/^w-(\d+)$/);
  if (match) return { width: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^h-(\d+)$/);
  if (match) return { height: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  match = className.match(/^max-w-(\d+)$/);
  if (match) return { maxWidth: spacingScale[match[1]] ?? parseInt(match[1]) * 4 };

  // Arbitrary values [100px], [#fff], etc.
  match = className.match(/^\w+-\[(.+)\]$/);
  if (match) {
    const prop = className.split('-[')[0];
    const value = match[1];

    // Map common properties
    const propMap: Record<string, string> = {
      'w': 'width', 'h': 'height', 'p': 'padding', 'm': 'margin',
      'px': 'paddingLeft', 'py': 'paddingTop', 'gap': 'gap',
      'text': 'fontSize', 'bg': 'backgroundColor', 'rounded': 'borderRadius',
    };

    const cssProp = propMap[prop];
    if (cssProp) {
      // Parse numeric values
      const numMatch = value.match(/^(\d+)px$/);
      if (numMatch) return { [cssProp]: parseInt(numMatch[1]) };
      return { [cssProp]: value };
    }
  }

  return null;
}

/**
 * Parse color classes like bg-slate-900, text-white, etc.
 */
function parseColorClass(className: string): Record<string, unknown> | null {
  // Common color values
  const colors: Record<string, string> = {
    'white': '#ffffff',
    'black': '#000000',
    'transparent': 'transparent',
    // Slate
    'slate-50': '#f8fafc', 'slate-100': '#f1f5f9', 'slate-200': '#e2e8f0',
    'slate-300': '#cbd5e1', 'slate-400': '#94a3b8', 'slate-500': '#64748b',
    'slate-600': '#475569', 'slate-700': '#334155', 'slate-800': '#1e293b',
    'slate-900': '#0f172a', 'slate-950': '#020617',
    // Gray
    'gray-50': '#f9fafb', 'gray-100': '#f3f4f6', 'gray-200': '#e5e7eb',
    'gray-300': '#d1d5db', 'gray-400': '#9ca3af', 'gray-500': '#6b7280',
    'gray-600': '#4b5563', 'gray-700': '#374151', 'gray-800': '#1f2937',
    'gray-900': '#111827', 'gray-950': '#030712',
    // Zinc
    'zinc-50': '#fafafa', 'zinc-100': '#f4f4f5', 'zinc-200': '#e4e4e7',
    'zinc-300': '#d4d4d8', 'zinc-400': '#a1a1aa', 'zinc-500': '#71717a',
    'zinc-600': '#52525b', 'zinc-700': '#3f3f46', 'zinc-800': '#27272a',
    'zinc-900': '#18181b', 'zinc-950': '#09090b',
    // Blue
    'blue-500': '#3b82f6', 'blue-600': '#2563eb', 'blue-700': '#1d4ed8',
    // Purple
    'purple-500': '#a855f7', 'purple-600': '#9333ea',
    // Pink
    'pink-500': '#ec4899', 'pink-600': '#db2777',
    // Red
    'red-500': '#ef4444', 'red-600': '#dc2626',
    // Green
    'green-500': '#22c55e', 'green-600': '#16a34a',
  };

  // Background color
  let match = className.match(/^bg-(.+)$/);
  if (match && colors[match[1]]) {
    return { backgroundColor: colors[match[1]] };
  }

  // Text color
  match = className.match(/^text-(.+)$/);
  if (match && colors[match[1]]) {
    return { color: colors[match[1]] };
  }

  // Border color
  match = className.match(/^border-(.+)$/);
  if (match && colors[match[1]]) {
    return { borderColor: colors[match[1]] };
  }

  return null;
}

/**
 * Convert Tailwind className string to canvas styles
 */
export function tailwindToStyles(className: string): Record<string, unknown> {
  const styles: Record<string, unknown> = {};
  const classes = className.split(/\s+/).filter(Boolean);

  for (const cls of classes) {
    // Skip responsive prefixes for now (sm:, md:, lg:, etc.)
    if (cls.includes(':')) continue;

    // Try static mappings first
    if (TAILWIND_MAPPINGS[cls]) {
      Object.assign(styles, TAILWIND_MAPPINGS[cls]());
      continue;
    }

    // Try numeric class parsing
    const numericStyles = parseNumericClass(cls);
    if (numericStyles) {
      Object.assign(styles, numericStyles);
      continue;
    }

    // Try color class parsing
    const colorStyles = parseColorClass(cls);
    if (colorStyles) {
      Object.assign(styles, colorStyles);
      continue;
    }
  }

  return styles;
}

/**
 * Determine element type from HTML tag
 */
function getElementType(tag: string): string {
  const tagMap: Record<string, string> = {
    'div': 'frame',
    'section': 'section',
    'header': 'section',
    'footer': 'section',
    'nav': 'row',
    'main': 'section',
    'article': 'frame',
    'aside': 'frame',
    'span': 'text',
    'p': 'text',
    'h1': 'text',
    'h2': 'text',
    'h3': 'text',
    'h4': 'text',
    'h5': 'text',
    'h6': 'text',
    'button': 'button',
    'a': 'button',
    'img': 'image',
    'input': 'input',
    'ul': 'stack',
    'ol': 'stack',
    'li': 'frame',
  };
  return tagMap[tag.toLowerCase()] || 'frame';
}

/**
 * Extract element name from className or generate one
 */
function generateElementName(tag: string, className: string, index: number): string {
  // Try to infer name from semantic classes
  if (className.includes('header')) return 'Header';
  if (className.includes('hero')) return 'Hero';
  if (className.includes('footer')) return 'Footer';
  if (className.includes('nav')) return 'Nav';
  if (className.includes('card')) return `Card${index}`;
  if (className.includes('button') || className.includes('btn')) return 'Button';

  // Default names based on tag
  const tagNames: Record<string, string> = {
    'h1': 'Title',
    'h2': 'Heading',
    'h3': 'Subheading',
    'p': 'Text',
    'button': 'Button',
    'img': 'Image',
    'section': 'Section',
    'header': 'Header',
    'footer': 'Footer',
    'nav': 'Nav',
  };

  return tagNames[tag.toLowerCase()] || `Element${index}`;
}

interface ParsedJSXElement {
  tag: string;
  className: string;
  children: (ParsedJSXElement | string)[];
  props: Record<string, string>;
}

/**
 * Simple JSX parser using regex
 * Note: This is a simplified parser that handles common cases.
 * For production, consider using @babel/parser
 */
function parseJSXString(jsx: string): ParsedJSXElement[] {
  const elements: ParsedJSXElement[] = [];

  // Remove comments
  jsx = jsx.replace(/\{\/\*[\s\S]*?\*\/\}/g, '');
  jsx = jsx.replace(/\/\/.*$/gm, '');

  // Simple recursive parser
  function parseElement(str: string, startIndex: number = 0): { element: ParsedJSXElement | string | null; endIndex: number } {
    str = str.trim();

    // Check for text content
    if (!str.startsWith('<')) {
      const nextTagIndex = str.indexOf('<');
      if (nextTagIndex === -1) {
        return { element: str.trim() || null, endIndex: str.length };
      }
      const text = str.substring(0, nextTagIndex).trim();
      return { element: text || null, endIndex: nextTagIndex };
    }

    // Parse opening tag
    const openTagMatch = str.match(/^<(\w+)([^>]*?)(\/?)>/);
    if (!openTagMatch) {
      return { element: null, endIndex: str.length };
    }

    const [fullMatch, tag, attrsStr, selfClosing] = openTagMatch;

    // Parse attributes
    const props: Record<string, string> = {};
    let className = '';

    // Extract className
    const classNameMatch = attrsStr.match(/className=["']([^"']+)["']/);
    if (classNameMatch) {
      className = classNameMatch[1];
    }

    // Extract src for images
    const srcMatch = attrsStr.match(/src=["']([^"']+)["']/);
    if (srcMatch) {
      props.src = srcMatch[1];
    }

    // Extract href for links
    const hrefMatch = attrsStr.match(/href=["']([^"']+)["']/);
    if (hrefMatch) {
      props.href = hrefMatch[1];
    }

    const element: ParsedJSXElement = {
      tag,
      className,
      children: [],
      props,
    };

    // Self-closing tag
    if (selfClosing === '/') {
      return { element, endIndex: fullMatch.length };
    }

    // Find matching closing tag and parse children
    let depth = 1;
    let currentIndex = fullMatch.length;
    let childrenStr = '';

    while (depth > 0 && currentIndex < str.length) {
      const openMatch = str.substring(currentIndex).match(/^<(\w+)/);
      const closeMatch = str.substring(currentIndex).match(/^<\/(\w+)>/);

      if (closeMatch && closeMatch[1] === tag) {
        depth--;
        if (depth === 0) {
          // Parse children
          if (childrenStr.trim()) {
            let childIndex = 0;
            while (childIndex < childrenStr.length) {
              const { element: child, endIndex } = parseElement(childrenStr.substring(childIndex));
              if (child) {
                element.children.push(child);
              }
              if (endIndex === 0) break;
              childIndex += endIndex;
            }
          }
          return { element, endIndex: currentIndex + closeMatch[0].length };
        }
      } else if (openMatch) {
        // Check if it's a self-closing tag
        const selfCloseCheck = str.substring(currentIndex).match(/^<\w+[^>]*\/>/);
        if (!selfCloseCheck) {
          depth++;
        }
      }

      childrenStr += str[currentIndex];
      currentIndex++;
    }

    return { element, endIndex: currentIndex };
  }

  // Parse top-level elements
  let index = 0;
  while (index < jsx.length) {
    const { element, endIndex } = parseElement(jsx.substring(index));
    if (element && typeof element !== 'string') {
      elements.push(element);
    }
    if (endIndex === 0) break;
    index += endIndex;
  }

  return elements;
}

/**
 * Convert parsed JSX element to CanvasElementData
 */
function jsxElementToCanvas(
  element: ParsedJSXElement | string,
  index: number = 0
): CanvasElementData | null {
  // Handle text nodes
  if (typeof element === 'string') {
    const text = element.trim();
    if (!text || text.startsWith('{')) return null; // Skip empty or JSX expressions

    return {
      type: 'text',
      name: 'Text',
      content: text,
      styles: {},
    };
  }

  const { tag, className, children, props } = element;
  const type = getElementType(tag);
  const name = generateElementName(tag, className, index);
  const styles = tailwindToStyles(className);

  // Build canvas element
  const canvasElement: CanvasElementData = {
    type,
    name,
    styles,
  };

  // Add content for text elements
  if (type === 'text' || type === 'button') {
    const textContent = children
      .filter((c): c is string => typeof c === 'string')
      .join(' ')
      .trim();
    if (textContent) {
      canvasElement.content = textContent;
    }
  }

  // Add src for images
  if (type === 'image' && props.src) {
    canvasElement.src = props.src;
  }

  // Add href for links/buttons
  if (props.href) {
    canvasElement.href = props.href;
  }

  // Process children (for containers)
  if (type !== 'text' && type !== 'button') {
    const childElements = children
      .map((child, i) => jsxElementToCanvas(child, i))
      .filter((c): c is CanvasElementData => c !== null);

    if (childElements.length > 0) {
      canvasElement.children = childElements;
    }
  }

  return canvasElement;
}

/**
 * Main function: Parse JSX/TSX code and convert to canvas elements
 */
export function parseJSXToCanvas(code: string): CanvasElementData[] {
  console.log('[JSX Parser] Parsing code...');

  // Extract JSX from the return statement
  const returnMatch = code.match(/return\s*\(\s*([\s\S]*?)\s*\);?\s*\}?\s*$/);
  const jsxContent = returnMatch ? returnMatch[1] : code;

  // Also try to find JSX in the whole code if return didn't match
  const jsxMatch = jsxContent.match(/<[\s\S]+>/);
  if (!jsxMatch) {
    console.warn('[JSX Parser] No JSX found in code');
    return [];
  }

  const jsx = jsxMatch[0];
  console.log('[JSX Parser] Found JSX:', jsx.substring(0, 200) + '...');

  // Parse JSX structure
  const parsedElements = parseJSXString(jsx);
  console.log('[JSX Parser] Parsed elements:', parsedElements.length);

  // Convert to canvas elements
  const canvasElements = parsedElements
    .map((el, i) => jsxElementToCanvas(el, i))
    .filter((el): el is CanvasElementData => el !== null);

  console.log('[JSX Parser] Canvas elements:', canvasElements.length);

  return canvasElements;
}

/**
 * Extract JSX code blocks from AI response
 */
export function extractJSXFromResponse(response: string): string[] {
  const codeBlocks: string[] = [];

  console.log('[extractJSX] Input length:', response.length);
  console.log('[extractJSX] First 300 chars:', JSON.stringify(response.substring(0, 300)));
  console.log('[extractJSX] Has backticks:', response.includes('```'));
  console.log('[extractJSX] Has tsx:', response.includes('tsx'));

  // Find backtick positions for debugging
  const backtickPos = response.indexOf('```');
  if (backtickPos >= 0) {
    console.log('[extractJSX] First ``` at position:', backtickPos);
    console.log('[extractJSX] Chars around first ```:', JSON.stringify(response.substring(Math.max(0, backtickPos - 5), backtickPos + 20)));
  }

  // Try multiple patterns to catch different code block formats
  // Pattern 1: ```tsx or ```jsx with newline (standard)
  let matches = response.matchAll(/```(?:tsx?|jsx?)\s*\n([\s\S]*?)```/gi);
  for (const match of matches) {
    console.log('[extractJSX] Found pattern 1 match, length:', match[1].length);
    codeBlocks.push(match[1]);
  }

  // Pattern 2: Just ``` with code that looks like React
  if (codeBlocks.length === 0) {
    matches = response.matchAll(/```\s*\n?([\s\S]*?)```/g);
    for (const match of matches) {
      const code = match[1];
      // Check if it looks like React code
      if (code.includes('export') || code.includes('function') || code.includes('return') || code.includes('<')) {
        console.log('[extractJSX] Found pattern 2 match (generic), length:', code.length);
        codeBlocks.push(code);
      }
    }
  }

  // Pattern 3: Try to find inline React component without code blocks
  if (codeBlocks.length === 0) {
    // Look for export default function or function Component patterns
    const inlineMatch = response.match(/((?:export\s+default\s+)?function\s+\w+\s*\([^)]*\)\s*\{[\s\S]*?return\s*\([\s\S]*?\)[;\s]*\})/);
    if (inlineMatch) {
      console.log('[extractJSX] Found inline component, length:', inlineMatch[1].length);
      codeBlocks.push(inlineMatch[1]);
    }
  }

  console.log('[extractJSX] Total code blocks found:', codeBlocks.length);
  return codeBlocks;
}

export default parseJSXToCanvas;
